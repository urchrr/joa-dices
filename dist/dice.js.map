{"version":3,"sources":["dice.ts"],"names":[],"mappings":"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","file":"dice.js","sourceRoot":"../src","sourcesContent":["// Yann CARDON 2019\n// Times of Legend, Joan of Arc dice rolls\n\n/** base class for dices */\nexport abstract class Dice {\n\n    /** the dice roll result */\n    readonly result: Map<Face, number> = new Map\n\n    /** the different faces of the dice */\n    abstract faces: Face[]\n\n    /** roll the dice once (or n times), if called multiple times then the results stack */\n    roll(times = 1): Dice {\n        for (let i=0; i<times; i++) {\n            let roll = this.faces[Math.floor(Math.random() * this.faces.length)]\n            if (roll) // if the dice has faces\n                this.result.set(roll, (this.result.get(roll) || 0) + 1)\n                console.debug(this.constructor.name, 'rolled a', this.result)\n            }\n        return this\n    }\n\n    /** reset the dice results */\n    reset(): Dice {\n        this.result.clear()\n        return this\n    }\n\n    /** add an other dice result (does not change the faces of the dice) */\n    add(other: Dice): Dice {\n        Faces.map(f => {\n            let sum = (this.result.get(f) || 0) + (other.result.get(f) || 0)\n            if (sum != 0) this.result.set(f, sum)\n        })\n        console.debug(this.constructor.name, 'sum is', this.result)\n        return this\n    }\n\n    /** convert the dice to an object, useful for logging */\n    toObject() {\n        let dice = {type: this.constructor.name, result: {} as any}\n        Array.from(this.result, ([face, number]) => {\n            dice.result[face] = number\n        })\n        return dice\n    }\n\n    /** remove faces (blank, shields... for instance) from the dice result */\n    filter(face: Face): Dice {\n        this.result.delete(face)\n        return this\n    }\n\n    /** apply a defense roll on a attack roll (shields faces are canceling the hit faces) */\n    applyDefense(defence: Dice): Dice {\n        this.lower(Face.Push, \n            this.lower(Face.Disrupt, \n                this.lower(Face.Kill, \n                    defence.result.get(Face.Shield) || 0)))\n        return this\n    }\n\n    /** lower the result @face value by the number of @shields then @return the remaining shields */\n    private lower(face: Face, shields: number): number {\n        let n = this.result.get(face)\n        if (n)\n            if (n-shields > 0) {\n                this.result.set(face, n-shields)\n                return 0\n            }\n            else {\n                this.result.delete(face)\n                return shields-n\n            }\n        return shields\n    }\n}\n\n/** the different dice faces */\nexport enum Face {\n    Kill =          'kill',             // Tué\n    Disrupt =       'disrupt',          // Hors combat\n    Push =          'push',             // Recul\n    Shield =        'shield',           // Bouclier\n    Blank =         'blank',            // Vide\n    Trample =       'trample',          // Piétinement\n    Death =         'death',            // Mort\n    Rally =         'rally',            // Ralliement\n    DelayedRally =  'delayed rally',    // Ralliement différé\n}\n\n/** an array of all the dice faces */\nconst Faces = Object.keys(Face).map(k => Face[k as any] as Face)\n\n/** common attack vs defence rolls */\nexport function attack(attackDice: Map<Dice, number>, defenceDice: Map<Dice, number> = new Map): object {\n    let attack = new EmptyDice\n    let defence = new EmptyDice\n\n    Array.from(attackDice, ([dice, times]) => attack.add(dice.roll(times)))\n    Array.from(defenceDice, ([dice, times]) => defence.add(dice.roll(times)))\n\n    if (defence.result.size == 0)\n        return {\n            attack: attack.toObject().result\n        }\n    else\n        return {\n            attack: attack.toObject().result,\n            defence: defence.toObject().result,\n            final: new EmptyDice()\n                .add(attack)\n                .applyDefense(defence)\n                .filter(Face.Blank).filter(Face.Shield)\n                .toObject().result\n        }\n}\n\n/** an dice without faces, used for dice calculations */\nexport class EmptyDice extends Dice {\n    faces = []\n}\n\n/** a black combat dice */\nexport class BlackDice extends Dice {\n    faces = [\n        Face.Kill,\n        Face.Disrupt,\n        Face.Shield,\n        Face.Disrupt,\n        Face.Shield,\n        Face.Shield,\n    ]\n}\n\n/** a red combat dice */\nexport class RedDice extends Dice {\n    faces = [\n        Face.Kill,\n        Face.Disrupt,\n        Face.Push,\n        Face.Disrupt,\n        Face.Kill,\n        Face.Shield,\n    ]\n}\n\n/** a yellow combat dice */\nexport class YellowDice extends Dice {\n    faces = [\n        Face.Blank,\n        Face.Disrupt,\n        Face.Push,\n        Face.Blank,\n        Face.Push,\n        Face.Shield,\n    ]\n}\n\n/** a white combat dice */\nexport class WhiteDice extends Dice {\n    faces = [\n        Face.Shield,\n        Face.Blank,\n        Face.Disrupt,\n        Face.Push,\n        Face.Disrupt,\n        Face.Shield,\n    ]\n}\n\n/** a purple gigantic combat dice */\nexport class GiganticDice extends Dice {\n    faces = [\n        Face.Kill,\n        Face.Disrupt,\n        Face.Disrupt,\n        Face.Trample,\n        Face.Trample,\n        Face.Push,\n    ]\n}\n\n/** a doom dice */\nexport class DoomDice extends Dice {\n    faces = [\n        Face.Disrupt,\n        Face.Rally,\n        Face.DelayedRally,\n        Face.Rally,\n        Face.Death,\n        Face.Death,\n    ]\n}\n"]}