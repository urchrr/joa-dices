{"version":3,"sources":["dice.ts","../node_modules/process/browser.js","dice-cli.ts"],"names":["cachedSetTimeout","cachedClearTimeout","process","module","exports","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","e","call","runClearTimeout","marker","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","Item","array","noop","nextTick","args","Array","arguments","i","push","prototype","apply","title","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask"],"mappings":"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","file":"dice-cli.js","sourceRoot":"../src","sourcesContent":["// Yann CARDON 2019\n// Times of Legend, Joan of Arc dice rolls\n\n/** base class for dices */\nexport abstract class Dice {\n\n    /** the dice roll result */\n    readonly result: Map<Face, number> = new Map\n\n    /** the different faces of the dice */\n    abstract faces: Face[]\n\n    /** roll the dice once (or n times), if called multiple times then the results stack */\n    roll(times = 1): Dice {\n        for (let i=0; i<times; i++) {\n            let roll = this.faces[Math.floor(Math.random() * this.faces.length)]\n            if (roll) // if the dice has faces\n                this.result.set(roll, (this.result.get(roll) || 0) + 1)\n                console.debug(this.constructor.name, 'rolled a', this.result)\n            }\n        return this\n    }\n\n    /** reset the dice results */\n    reset(): Dice {\n        this.result.clear()\n        return this\n    }\n\n    /** add an other dice result (does not change the faces of the dice) */\n    add(other: Dice): Dice {\n        Faces.map(f => {\n            let sum = (this.result.get(f) || 0) + (other.result.get(f) || 0)\n            if (sum != 0) this.result.set(f, sum)\n        })\n        console.debug(this.constructor.name, 'sum is', this.result)\n        return this\n    }\n\n    /** convert the dice to an object, useful for logging */\n    toObject() {\n        let dice = {type: this.constructor.name, result: {} as any}\n        Array.from(this.result, ([face, number]) => {\n            dice.result[face] = number\n        })\n        return dice\n    }\n\n    /** remove faces (blank, shields... for instance) from the dice result */\n    filter(face: Face): Dice {\n        this.result.delete(face)\n        return this\n    }\n\n    /** apply a defense roll on a attack roll (shields faces are canceling the hit faces) */\n    applyDefense(defence: Dice): Dice {\n        this.lower(Face.Push, \n            this.lower(Face.Disrupt, \n                this.lower(Face.Kill, \n                    defence.result.get(Face.Shield) || 0)))\n        return this\n    }\n\n    /** lower the result @face value by the number of @shields then @return the remaining shields */\n    private lower(face: Face, shields: number): number {\n        let n = this.result.get(face)\n        if (n)\n            if (n-shields > 0) {\n                this.result.set(face, n-shields)\n                return 0\n            }\n            else {\n                this.result.delete(face)\n                return shields-n\n            }\n        return shields\n    }\n}\n\n/** the different dice faces */\nexport enum Face {\n    Kill =          'kill',             // Tué\n    Disrupt =       'disrupt',          // Hors combat\n    Push =          'push',             // Recul\n    Shield =        'shield',           // Bouclier\n    Blank =         'blank',            // Vide\n    Trample =       'trample',          // Piétinement\n    Death =         'death',            // Mort\n    Rally =         'rally',            // Ralliement\n    DelayedRally =  'delayed rally',    // Ralliement différé\n}\n\n/** an array of all the dice faces */\nconst Faces = Object.keys(Face).map(k => Face[k as any] as Face)\n\n/** common attack vs defence rolls */\nexport function attack(attackDice: Map<Dice, number>, defenceDice: Map<Dice, number> = new Map): object {\n    let attack = new EmptyDice\n    let defence = new EmptyDice\n\n    Array.from(attackDice, ([dice, times]) => attack.add(dice.roll(times)))\n    Array.from(defenceDice, ([dice, times]) => defence.add(dice.roll(times)))\n\n    if (defence.result.size == 0)\n        return {\n            attack: attack.toObject().result\n        }\n    else\n        return {\n            attack: attack.toObject().result,\n            defence: defence.toObject().result,\n            final: new EmptyDice()\n                .add(attack)\n                .applyDefense(defence)\n                .filter(Face.Blank).filter(Face.Shield)\n                .toObject().result\n        }\n}\n\n/** an dice without faces, used for dice calculations */\nexport class EmptyDice extends Dice {\n    faces = []\n}\n\n/** a black combat dice */\nexport class BlackDice extends Dice {\n    faces = [\n        Face.Kill,\n        Face.Disrupt,\n        Face.Shield,\n        Face.Disrupt,\n        Face.Shield,\n        Face.Shield,\n    ]\n}\n\n/** a red combat dice */\nexport class RedDice extends Dice {\n    faces = [\n        Face.Kill,\n        Face.Disrupt,\n        Face.Push,\n        Face.Disrupt,\n        Face.Kill,\n        Face.Shield,\n    ]\n}\n\n/** a yellow combat dice */\nexport class YellowDice extends Dice {\n    faces = [\n        Face.Blank,\n        Face.Disrupt,\n        Face.Push,\n        Face.Blank,\n        Face.Push,\n        Face.Shield,\n    ]\n}\n\n/** a white combat dice */\nexport class WhiteDice extends Dice {\n    faces = [\n        Face.Shield,\n        Face.Blank,\n        Face.Disrupt,\n        Face.Push,\n        Face.Disrupt,\n        Face.Shield,\n    ]\n}\n\n/** a purple gigantic combat dice */\nexport class GiganticDice extends Dice {\n    faces = [\n        Face.Kill,\n        Face.Disrupt,\n        Face.Disrupt,\n        Face.Trample,\n        Face.Trample,\n        Face.Push,\n    ]\n}\n\n/** a doom dice */\nexport class DoomDice extends Dice {\n    faces = [\n        Face.Disrupt,\n        Face.Rally,\n        Face.DelayedRally,\n        Face.Rally,\n        Face.Death,\n        Face.Death,\n    ]\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","// Yann CARDON 2019\n// Times of Legend, Joan of Arc dice rolls\n\nimport { BlackDice, RedDice, YellowDice, WhiteDice, GiganticDice, DoomDice, attack, Dice } from \"./dice\";\n\nexport const isFrenchUI = true\n\n/** CLI dice wrapper */\nexport function parseCLI(command: string[]) {\n\n    let attackDice = new Map\n    let defenceDice = new Map\n    let isDefence = false\n\n    command.map(arg => {\n        let times = parseInt(arg.slice(0, -1))\n        switch (arg.slice(-1)) {\n\n            // defense switch\n            case '-':\n            case '/':\n            case ':':\n                isDefence = true\n                break\n\n            // [N]oir\n            case 'N':\n            case 'n':\n                addAttackOrDefense(new BlackDice, times)\n                break\n\n            // [R]ouge or [R]ed\n            case 'R':\n            case 'r':\n                addAttackOrDefense(new RedDice, times)\n                break\n\n            // [J]aune or [Y]ellow\n            case 'J':\n            case 'j':\n            case 'Y':\n            case 'y':\n                addAttackOrDefense(new YellowDice, times)\n                break\n\n            // [B]lanc or [B]lack\n            case 'B':\n            case 'b':\n                if (isFrenchUI) addAttackOrDefense(new WhiteDice, times)\n                else addAttackOrDefense(new BlackDice, times)\n                break\n\n            // [W]hite\n            case 'W':\n            case 'w':\n                addAttackOrDefense(new WhiteDice, times)\n                break\n            \n            // [G]igantesque or [G]igantic\n            case 'G':\n            case 'g':\n                addAttackOrDefense(new GiganticDice, times)\n                break\n            \n            // [D]estin or [D]oom\n            case 'D':\n            case 'd':\n                addAttackOrDefense(new DoomDice, times)\n                break\n\n            default:\n                console.error('bad syntax')\n                process.exit(-1)\n        }\n    })\n\n    console.log(attack(attackDice, defenceDice))\n\n    /** add the dice result either to attack or defence according to the CLI context */\n    function addAttackOrDefense(dice: Dice, times: number) {\n        if (isDefence) defenceDice.set(dice, times + (defenceDice.get(dice) || 0))\n        else attackDice.set(dice, times + (attackDice.get(dice) || 0))\n    }\n}\n\n// disable debug logs\nconsole.debug = (..._: any[]) => {}\n\n// parse CLI and roll dices\nparseCLI(process.argv.slice(2))\n"]}